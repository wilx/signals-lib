#if ! defined (SIGNALS_LIB_SIGNALS_HXX)
#define SIGNALS_LIB_SIGNALS_HXX

#include <versions-lib/versions.hxx>

#if VERSIONS_LIB_LINUX_PREREQ (2, 6, 22)         \
    && VERSIONS_LIB_GLIBC_PREREQ (2, 8)
#define SIGNALS_LIB_HAVE_SIGNALFD
#include <sys/signalfd.h>
#endif

#if VERSIONS_LIB_LINUX_PREREQ (2, 6, 27)         \
    && VERSIONS_LIB_GLIBC_PREREQ (2, 9)
#define SIGNALS_LIB_HAVE_PIPE2
#endif

#include <signal.h>
#include <pthread.h>
#include <unistd.h>
#include <poll.h>
#include <fcntl.h>

#include <thread>
#include <vector>
#include <atomic>
#include <memory>
#include <mutex>
#include <chrono>
#include <type_traits>
#include <utility>
#include <limits>
#include <stdexcept>
#include <system_error>
#include <cstring>
#include <cstdint>


namespace signalslib
{


inline
void
throw_system_error (int eno, char const * function)
{
    throw std::system_error (eno, std::system_category (),
        function);
}


struct scoped_signals_blocker
{
    sigset_t old;

    scoped_signals_blocker (sigset_t blocked_signals)
    {
        int ret = pthread_sigmask (SIG_BLOCK, &blocked_signals, &old);
        if (ret != 0)
            throw_system_error (ret, "pthread_sigmask");

    }

    ~scoped_signals_blocker () throw (std::system_error)
    {
        int ret = pthread_sigmask (SIG_SETMASK, &old, nullptr);
        if (ret != 0)
            throw_system_error (ret, "pthread_sigmask");
    }
};


inline
size_t
get_sigmax ()
{
#if defined (SIGRTMAX)
    return SIGRTMAX;
#else
    return 64;
#endif
}


template <typename Sigset, typename Functor>
typename std::enable_if<
    std::is_same<
        typename std::remove_reference<Sigset>::type,
        sigset_t>::value
    >::type
for_each_signal (Sigset && sigset, Functor func)
{
    int const max = get_sigmax ();
    for (int i = 0; i != max; ++i)
    {
        int const ret = sigismember (&sigset, i);
        if (ret == -1)
            continue;

        func (i, !! ret);
    }
}


inline
sigset_t
get_reasonable_blocking_sigset_t ()
{
    sigset_t blocked_signals;
    sigfillset (&blocked_signals);

    // From pthread_sigmask() page in IEEE Std 1003.1, 2013 Edition:
    //
    // If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated
    // while they are blocked, the result is undefined, unless the signal was
    // generated by the action of another process, or by one of the functions
    // kill(), pthread_kill(), raise(), or sigqueue().
    //
    // So we unblock these explicitly here.

    sigdelset (&blocked_signals, SIGFPE);
    sigdelset (&blocked_signals, SIGILL);
    sigdelset (&blocked_signals, SIGSEGV);
    sigdelset (&blocked_signals, SIGBUS);

    return blocked_signals;
}


inline
bool
try_set_close_on_exec (int fd)
{
    int ret = -1;
#if defined (FD_CLOEXEC)
    ret = fcntl (fd, F_SETFD, FD_CLOEXEC);
#endif
    return ret != -1;
}


//
//
//

//! This structure gets written into pipe from signal handler to convey all the
//! necessary information to the handling thread.
struct posix_signal_info
{
    int signo;
    siginfo_t siginfo;
    ucontext_t context;
};


//! This structure is here to convey signal information provided by various
//! different signal handling facilities to the user callback. The individual
//! members are filled from `si_*` members of `siginfo_t` or
//! `signalfd_siginfo_t`.
struct signal_info
{
    std::uint_least32_t signo;
    std::int_least32_t code;
    std::int_least32_t eno;
    pid_t pid;
    uid_t uid;
    int fd;
    std::uint_least32_t tid;
    void * addr;
    std::int_least32_t status;
    std::int_least64_t band;
    std::uint_least32_t overrun;
    std::uint_least32_t trapno;
    std::uint_least64_t utime;
    std::uint_least64_t stime;

    // De-multiplexed members of `union sigval`.

    int int_value;
    void * ptr_value;

    // Context provided in POSIX signal handler function.

    ucontext_t context;
};


template <typename DestType, typename SrcType>
void
copy_field (DestType & dest, SrcType const & src)
{
    SrcType tmp;
    std::memcpy (&tmp, &src, sizeof (SrcType));
    static_assert (sizeof (DestType) >= sizeof (SrcType), "");
    dest = static_cast<DestType>(tmp);
}


template <typename DestType, typename SrcType>
void
copy_field (DestType * & dest, SrcType const & src)
{
    SrcType tmp;
    std::memcpy (&tmp, &src, sizeof (SrcType));
    static_assert (sizeof (DestType *) == sizeof (SrcType), "");
    dest = reinterpret_cast<DestType *>(tmp);
}


//
//
//

enum FDs
{
    SIGNALS_FD = 0,
    SHUTDOWN_FD = 1,
};

enum PipeEnds
{
    READ_END = 0,
    WRITE_END = 1
};


struct Handler
{
    virtual ~Handler () noexcept (false) = 0;
};


inline
Handler::~Handler () noexcept (false)
{ }


//
//
//


inline
int
xwrite (int fd, void const * buf, std::size_t size)
{
    int ret;
    do
        ret = write (fd, buf, size);
    while (ret == -1 && errno == EINTR);
    if (ret == -1)
        throw_system_error (errno, "write");
    return ret;
}


inline
int
xpoll (struct pollfd * pollfds, int nfds, int timeout)
{
    int ret;
    do
        ret = poll (&pollfds[0], nfds, timeout);
    while ((ret == -1
            && errno == EINTR)
        || ret == 0);
    return ret;
}


inline
int
xread (int fd, void * buf_ptr, std::size_t buf_size)
{
    long read_bytes = 0;
    char * buf = static_cast<char *>(buf_ptr);
    do
    {
        long const res = read (fd, buf + read_bytes, buf_size - read_bytes);
        if (res == -1 && errno == EINTR)
            continue;
        else if (res == -1)
            throw_system_error (errno, "read");

        read_bytes += res;
    }
    while (static_cast<std::size_t>(read_bytes) < buf_size);

    return read_bytes;
}


inline
int
xclose (int fd)
{
    int ret;
    while ((ret = close (fd)) == -1
        && errno == EINTR)
        ;
    if (ret == -1)
        throw_system_error (errno, "close");

    return ret;
}


using signal_handler_callback_type =
    std::function<void (signal_info const &)>;


inline
int
create_pipe (std::array<int, 2> & fds)
{
    int ret;

#if defined (SIGNALS_LIB_HAVE_PIPE2)
    ret = pipe2 (&fds[0], O_CLOEXEC);
    if (ret == -1)
        throw_system_error (errno, "pipe2");

#else
    ret = pipe (&fds[0]);
    if (ret == -1)
        throw_system_error (errno, "pipe");

    try_set_close_on_exec (fds[0]);
    try_set_close_on_exec (fds[1]);

#endif

    return ret;
}


//
//
//

class HandlerBase
    : public virtual Handler
{
public:
    HandlerBase (sigset_t const & s, signal_handler_callback_type cb)
        : signals (s)
        , callback (std::move (cb))
    {
        create_pipe (shutdown_pipe_fds);
    }

    HandlerBase () = delete;
    HandlerBase (HandlerBase const &) = delete;
    HandlerBase (HandlerBase &&) = delete;
    HandlerBase & operator = (HandlerBase const &) = delete;
    HandlerBase & operator = (HandlerBase &&) = delete;

    virtual
    ~HandlerBase () noexcept (false)
    {
        xclose (get_shutdown_fd_write_end ());
        xclose (get_shutdown_fd_read_end ());
    }

    void
    signal_shutdown ()
    {
        char const ch = 'S';
        xwrite (get_shutdown_fd_write_end (), &ch, 1);
    }

    void
    wait_shutdown ()
    {
        handler_thread->join ();
    }

    int
    get_shutdown_fd_read_end () const
    {
        return shutdown_pipe_fds[READ_END];
    }

    int
    get_shutdown_fd_write_end () const
    {
        return shutdown_pipe_fds[WRITE_END];
    }

    FDs
    poll_fds (int signals_fd, int shutdown_fd)
    {
        std::array<struct pollfd, 2> pollfds;

        struct pollfd & signals_pollfd = pollfds[SIGNALS_FD];
        signals_pollfd.fd = signals_fd;
        signals_pollfd.events = POLLIN;
        signals_pollfd.revents = 0;

        struct pollfd & shutdown_pollfd = pollfds[SHUTDOWN_FD];
        shutdown_pollfd.fd = shutdown_fd;
        shutdown_pollfd.events = POLLIN;
        shutdown_pollfd.revents = 0;

        xpoll (&pollfds[0], 2, -1);

        if ((shutdown_pollfd.revents & POLLIN) == POLLIN)
            return SHUTDOWN_FD;
        else if ((signals_pollfd.revents & POLLIN) == POLLIN)
            return SIGNALS_FD;

        throw std::logic_error ("unknown handle signaled");
    }

protected:
    sigset_t signals;
    std::array<int, 2> shutdown_pipe_fds;
    std::unique_ptr<std::thread> handler_thread;
    signal_handler_callback_type callback;
};


//
//
//

using signal_handler_function_type = void (*) (int, siginfo_t *, void *);


inline
struct sigaction
install_sig_handler(signal_handler_function_type func, int sig)
{
    struct sigaction act{};
    act.sa_flags = SA_SIGINFO;
    act.sa_sigaction = func;
    act.sa_mask = get_reasonable_blocking_sigset_t ();

    struct sigaction old;
    int ret = sigaction (sig, &act, &old);
    if (ret == -1)
        throw_system_error (errno, "sigaction");

    return old;
}


inline
void
restore_sig_handler (struct sigaction const & old_act, int sig)
{
    int ret = sigaction (sig, &old_act, nullptr);
    if (ret == -1)
        throw_system_error (errno, "sigaction");
}


} // namespace signalslib


extern "C"
inline
void
signalslib_signal_handler_func  (int sig, siginfo_t * siginfo, void * context);


namespace signalslib
{


class PosixHandler
    : public HandlerBase
{
public:
    PosixHandler (sigset_t const & s, signal_handler_callback_type cb)
        : HandlerBase (s, std::move (cb))
        , old_sigactions (get_sigmax ())
    {
        create_pipe (signals_pipe_fds);

        // Block (almost) all signals.

        sigset_t blocked_signals = get_reasonable_blocking_sigset_t ();
        scoped_signals_blocker sig_blocker (blocked_signals);

        // Install signal handlers for signals that interest us.

        for_each_signal (signals, [this](int sig, bool is_set)
            {
                if (! is_set)
                    return;

                set_handler_ptr (sig, this);

                struct sigaction old_act;
                old_act = install_sig_handler (
                    signalslib_signal_handler_func, sig);
                set_old_sigaction (sig, old_act);
            });

        handler_thread.reset (
            new std::thread (&PosixHandler::thread_function, this));
    }

    virtual
    ~PosixHandler () noexcept (false)
    {
        restore_signal_handlers ();
        signal_shutdown ();
        wait_shutdown ();
        for_each_signal (signals, [](int sig, bool is_set)
            {
                if (is_set)
                    set_handler_ptr (sig,  nullptr);
            });
        xclose (get_signals_fd_read_end ());
        xclose (get_signals_fd_write_end ());
    }

protected:
    void
    handle_one_signal ()
    {
        posix_signal_info psi;
        xread (get_signals_fd_read_end (), &psi, sizeof (psi));

        signal_info si;

        // Members of siginfo_t as described by SUS.

        copy_field (si.signo, psi.siginfo.si_signo);
        copy_field (si.code, psi.siginfo.si_code);
        copy_field (si.eno, psi.siginfo.si_errno);
        copy_field (si.pid, psi.siginfo.si_pid);
        copy_field (si.uid, psi.siginfo.si_uid);
        copy_field (si.addr, psi.siginfo.si_addr);
        copy_field (si.status, psi.siginfo.si_status);
        copy_field (si.band, psi.siginfo.si_band);

        // De-multiplexed members of `union sigval`.

        copy_field (si.int_value, psi.siginfo.si_value.sival_int);
        copy_field (si.ptr_value, psi.siginfo.si_value.sival_ptr);

        // Members of siginfo_t outside of SUS.

#if defined (__linux__)
        copy_field (si.fd, psi.siginfo.si_fd);
#endif
#if defined (__FreeBSD__)
        copy_field (si.mpq, psi.siginfo.si_mpq);
        copy_field (si.trapno, psi.siginfo.si_trapno);
#endif
#if defined (__linux__) \
    || defined (__FreeBSD__)
        copy_field (si.tid, psi.siginfo.si_timerid);
        copy_field (si.overrun, psi.siginfo.si_overrun);

        copy_field (si.utime, psi.siginfo.si_utime);
        copy_field (si.stime, psi.siginfo.si_stime);
#endif

        // Thread context.

        si.context = psi.context;

        callback (si);
    }


    void
    thread_function ()
    {
        // Unblock signals that interest us. They can be blocked in all other
        // threads.

        int ret = pthread_sigmask (SIG_UNBLOCK, &signals, nullptr);
        if (ret != 0)
            throw_system_error (ret, "pthread_sigmask");

        // Poll signals and shutdown file descriptors.

        for (;;)
        {
            // Poll handles here.
            FDs signaled_handle = poll_fds (get_signals_fd_read_end (),
                get_shutdown_fd_read_end ());
            switch (signaled_handle)
            {
            case SIGNALS_FD:
                handle_one_signal ();
                break;

            case SHUTDOWN_FD:
                return;

            default:
                throw std::logic_error ("unknown handle kind signaled");
            }
        }
    }


    void
    restore_signal_handlers ()
    {
        for_each_signal (signals, [this](int sig, bool is_set)
            {
                if (! is_set)
                    return;

                struct sigaction old_act = get_old_sigaction (sig);
                restore_sig_handler (old_act, sig);
                set_handler_ptr (sig, nullptr);
            });
    }


    int
    get_signals_fd_read_end () const
    {
        return signals_pipe_fds[READ_END];
    }


    int
    get_signals_fd_write_end () const
    {
        return signals_pipe_fds[WRITE_END];
    }

    friend void ::signalslib_signal_handler_func  (int sig, siginfo_t * siginfo,
        void * context);


    std::array<int, 2> signals_pipe_fds;
    std::vector<struct sigaction> old_sigactions;

    static std::vector<std::atomic<PosixHandler *> > handlers;


    static
    void
    set_handler_ptr (std::size_t slot, PosixHandler * handler)
    {
        if (slot >= PosixHandler::handlers.size ())
            throw std::out_of_range ("");

        handlers[slot].store (handler);
    }


    static
    PosixHandler *
    get_handler_ptr (std::size_t slot)
    {
        if (slot >= PosixHandler::handlers.size ())
            throw std::out_of_range ("");

        return handlers[slot].load ();
    }


    struct sigaction
    get_old_sigaction (std::size_t slot)
    {
        if (slot >= PosixHandler::old_sigactions.size ())
            throw std::out_of_range ("");

        return old_sigactions[slot];
    }


    void
    set_old_sigaction (std::size_t slot, struct sigaction const & old_act)
    {
        if (slot >= PosixHandler::old_sigactions.size ())
            throw std::out_of_range ("");

        old_sigactions[slot] = old_act;
    }
};


} // namespace signalslib


extern "C"
inline
void
signalslib_signal_handler_func  (int sig, siginfo_t * siginfo, void * context)
{
    using namespace signalslib;

    PosixHandler * const handler = PosixHandler::get_handler_ptr (sig);
    int const signals_fd = handler->get_signals_fd_write_end ();
    posix_signal_info const si {sig, siginfo ? *siginfo : siginfo_t (),
            context ? *reinterpret_cast<ucontext_t *>(context) : ucontext_t ()};
    int ret = xwrite (signals_fd, &si, sizeof (si));
    if (ret == -1)
        std::abort ();
    else if (ret < static_cast<int>(sizeof (si)))
        std::abort ();
}


namespace signalslib
{


#if VERSIONS_LIB_LINUX_PREREQ (2, 6, 22) \
    && VERSIONS_LIB_GLIBC_PREREQ (2, 8)

inline
int
create_signalfd (sigset_t const & signals)
{
    int flags = 0;

    bool const have_sfd_cloexec
        = versionslib::get_linux_rt_version ()
            >= versionslib::version_triple {2, 6, 27}
        && versionslib::get_glibc_rt_version ()
            >= versionslib::version_triple {2, 9, 0}
        &&
#if defined (SFD_CLOEXEC)
            true
#else
            false
#endif
            ;

    if (have_sfd_cloexec)
    {

#if defined (SFD_CLOEXEC)
        flags = SFD_CLOEXEC;
#endif
    }

    int ret = signalfd (-1, &signals, flags);
    if (ret == -1)
        throw_system_error (errno, "signalfd");

    if (! have_sfd_cloexec)
        try_set_close_on_exec (ret);

    return ret;
}


class SignalFDHandler
    : public HandlerBase
{
public:
    SignalFDHandler (sigset_t const & s, signal_handler_callback_type cb)
        : HandlerBase (s, std::move (cb))
    {
        // Block most signals.

        sigset_t blocked_signals = get_reasonable_blocking_sigset_t ();
        scoped_signals_blocker blocker (blocked_signals);

        signals_fd = create_signalfd (signals);
        handler_thread.reset (
            new std::thread (&SignalFDHandler::thread_function, this));
    }

    virtual
    ~SignalFDHandler () noexcept (false)
    {
        signal_shutdown ();
        wait_shutdown ();
        xclose (signals_fd);
    }

protected:
    void
    handle_one_signal ()
    {
        struct signalfd_siginfo fdsi;
        xread (get_signals_fd (), &fdsi, sizeof (fdsi));

        signal_info si;
        copy_field (si.signo, fdsi.ssi_signo);
        copy_field (si.eno, fdsi.ssi_errno);
        copy_field (si.code, fdsi.ssi_code);
        copy_field (si.pid, fdsi.ssi_pid);
        copy_field (si.uid, fdsi.ssi_uid);
        copy_field (si.fd, fdsi.ssi_fd);
        //copy_field (si.timerid, fdsi.ssi_timerid);
        copy_field (si.band, fdsi.ssi_band);
        copy_field (si.overrun, fdsi.ssi_overrun);
        copy_field (si.trapno, fdsi.ssi_trapno);
        copy_field (si.status, fdsi.ssi_status);
        copy_field (si.int_value, fdsi.ssi_int);
        copy_field (si.ptr_value, fdsi.ssi_ptr);
        copy_field (si.utime, fdsi.ssi_utime);
        copy_field (si.stime, fdsi.ssi_stime);
        copy_field (si.addr, fdsi.ssi_addr);

        callback (si);
    }


    void
    thread_function ()
    {
        // If one of the still not blocked signals is one of those that
        // interest us, block them as well so that the signalfd() mechanism can
        // work.

        int ret = pthread_sigmask (SIG_BLOCK, &signals, nullptr);
        if (ret != 0)
            throw_system_error (ret, "pthread_sigmask");

        // Poll signals and shutdown file descriptors.

        for (;;)
        {
            // Poll handles here.
            FDs signaled_handle = poll_fds (get_signals_fd (),
                get_shutdown_fd_read_end ());
            switch (signaled_handle)
            {
            case SIGNALS_FD:
                handle_one_signal ();
                break;

            case SHUTDOWN_FD:
                return;

            default:
                throw std::logic_error ("unknown handle kind signaled");
            }
        }
    }


    int
    get_signals_fd () const
    {
        return signals_fd;
    }


    int signals_fd;
};

#endif // PREREQ

} // namespace signalslib

#endif // SIGNALS_LIB_SIGNALS_HXX
